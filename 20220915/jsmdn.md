# JavaScript
- 웹 페이지에서 복잡한 기능을 구현할 수 있도록 하는 스크립팅 언어 또는 프로그래밍 언어
- 사용자와 상호작용이 가능하거나, 애니메이션이 적용된 2d/3d에는 JavaScript가 관여하고있을것이다.
- 동적으로 콘텐츠를 바꾸고, 멀티미디어를 제어하고, 애니메이션을 추가하는 등 거의 모든 것을 만들 수 있는 스크립팅 언어입니다.
# API
- 애플리케이션 프로그래밍 인터페이스(API)
- 개발자가 직접 구현하기는 어렵거나 불가능한 기능들을 미리 만들어서 제공한다.
## 브라우저 API
- 웹 브라우저에 내장된 API
- 현재 컴퓨터 환경에 관한 데이터를 제고앟거나 여러가지 유용하고 복잡한 일을 수행한다.
- DOM (Document Object Model) API
  - HTML 콘텐츠를 추가, 제거, 변경하고, 동적으로 페이지에 스타일을 추가하는 등 HTML/CSS를 조작할 수 있습니다. 페이지 위에 뜨는 팝업창이나, (위쪽의 간단한 예제처럼) 새로운 콘텐츠가 나타나는 것을 본 적이 있으면 DOM이 동작한 겁니다
- Geolocation API
  -  지리정보를 가져올 수 있습니다. Google 지도에서 여러분의 위치를 찾아 지도에 그릴 수 있는 이유가 바로 이 API입니다.
- Canvas와 WebGL API
  -  애니메이션을 적용한 2D와 3D 그래픽을 만들 수 있습니다. 두 웹 기술을 사용해서 만들 수 있는 놀라운 결과를 엿보려면 Chrome Experiments와 webglsamples를 방문하세요
- HTMLMediaElement와 WebRTC를 포함하는 오디오와 비디오 API
  -  멀티미디어를 사용한 흥미로운 일을 할 수 있습니다. 예를 들어 오디오나 비디오를 웹 페이지에서 바로 재생하거나, 여러분의 웹캠으로 비디오를 찍어 다른 사람의 화면에 보여줄 수 있습니다. (간단한 스냅샷 데모를 방문해서 감을 잡아보세요)
**JavaScript 실행순서**
- 위->아래
# 문법과 자료형
## 기본 문법
- JavaScript는 **대소문자**를 구별하며 **유니코드** 문자셋을 이용합니다.
- 명령을 명령문(statement)이라고 부르며, 세미콜론(;)으로 구분
- 명령문이 한 줄을 다 차지할 경우에는 세미콜론이 필요하지 않다.
- 그러나 한 줄에 두 개 이상의 명령문이 필요하다면 반드시 세미콜론으로 구분해야한다.
- 세미콜론이 필요하지 않은 경우에도 세미콜론으로 끝마치는 편이 버그 예방 차원에서 더 좋은 습관입니다.
- JavaScript의 스크립트 소스는 왼쪽에서 오른쪽으로 탐색하면서 토큰, 제어 문자, 줄바꿈 문자, 주석이나 공백 (en-US)으로 이루어진 입력 요소의 시퀀스로 변환됩니다. (스페이스, 탭, 줄바꿈 문자는 공백으로 간주됩니다.)
## 주석
  ```javascript
  // 한 줄 주석
  /* 여러줄
   * 주석
   * 처리
  */
  ```
## 선언
### var
- 변수를 선언, 추가로 동시에 값을 초기화
### let
- 블록 스코프 지역 변수를 선언. 추가로 동시에 값을 초기화.
### const
- 블록 스코프 읽기 전용 상수를 선언
## 변수
- 애플리케이션에서 값에 상징적인 이름으로 변수를 사용합니다. 변수명은 식별자(identifiers)라고 불리며 특정 규칙을 따릅니다.
- 문자, 밑줄 (_) 혹은 달러 기호 ($)로 시작해야 하는 반면 이후는 숫자 (0–9) 일 수도 있습니다.
- JavaScript가 대소문자를 구분하기에, 문자는 "A"부터 "Z" (대문자)와 "a"부터 "z" (소문자)까지 모두 포함합니다.
- SO 8859-1 혹은 Unicode 문자(가령 å 나 ü)도 식별자에 사용할 수 있습니다.
### 변수 선언
- var x = 42와 같이 var 키워드로 변수를 선언할 수 있습니다. <br>이 구문은 실행 맥락에 따라 지역 및 전역 변수를 선언하는데 모두 사용될 수 있습니다.
- let y = 13와 같이 const 혹은 let 키워드로 변수를 선언할 수 있습니다. <br>이 구문은 블록 스코프 지역 변수를 선언하는데 사용될 수 있습니다. 아래 변수 스코프를 참고하세요.
- 구조 분해 할당 구문을 사용하여 객체 리터럴에서 값을 풀기 위해 변수를 선언할 수 있습니다. <br>예를 들면, let { bar } = foo. 이 구문은 bar라는 이름의 변수를 생성하고 foo 객체에 있는 동일한 이름의 키에 해당하는 값을 변수에 할당합니다.
### 변수 할당
- 지정된 초기 값 없이 var 혹은 let 문을 사용해서 선언된 변수는 undefined 값을 갖습니다.
- 선언되지 않은 변수에 접근을 시도하는 경우 ReferenceError 예외가 발생합니다
```javascript
var a;
console.log('a 값은 ' + a); // a 값은 undefined

console.log('b 값은 ' + b); // b 값은 undefined
var b;
// 이것은 아래의 '변수 호이스팅'을 읽기 전에는 혼란스러울 수 있음

console.log('c 값은 ' + c); // Uncaught ReferenceError: c is not defined

let x;
console.log('x 값은 ' + x); // x 값은 undefined

console.log('y 값은 ' + y); // Uncaught ReferenceError: y is not defined
let y;
```
### 변수 스코프
- 어떤 함수의 바깥에 변수를 선언하면, 현재 문서의 다른 코드에 해당 변수를 사용할 수 있기에 **전역 변수**라고 합니다. 
- 만약 함수 내부에 변수를 선언하면, 오직 그 함수 내에서만 사용할 수 있기에 **지역 변수**라고 부릅니다.
### 호이스팅
- JavaScript 변수가 어떤 의미에서 함수나 문의 최상단으로 "올려지는" (혹은 "끌어올려지는") 것을 말합니다. 
- 하지만, 끌어올려진 변수는 undefined 값을 반환합니다. 
- 그래서 심지어 이 변수를 사용 혹은 참조한 후에 선언 및 초기화하더라도, 여전히 undefined를 반환합니다.
- 호이스팅 때문에, 함수 내의 모든 var 문은 가능한 함수 상단 근처에 두는 것이 좋습니다. 이 방법은 코드를 더욱 명확하게 만들어줍니다.
- ECMAScript 2015의 let과 const는 변수를 블록의 상단으로 끌어올리지만 초기화하지 않습니다. 변수가 선언되기 전에 블록 안에서 변수를 참조하게 되면 ReferenceError를 발생시키게 되는데, 변수는 블록 시작부터 선언이 처리될 때까지 "temporal dead zone"에 위치하게 되기 때문입니다.
- 함수에서는 함수 선언으로는 호이스팅되지만 함수 표현식으로는 호이스팅 되지 않습니다.
### 전역 변수
- 전역 객체의 속성(property)입니다.
- 웹 페이지에서 전역 객체는 window 이므로, windows.variable 구문을 통해 전역 변수를 설정하고 접근할 수 있습니다.
- window 혹은 frame의 이름을 지정하여 한 window 혹은 frame에서 다른 window 혹은 frame에 선언된 전역 변수에 접근할 수 있습니다. 
### 상수
- const 키워드로 읽기 전용 상수를 만들 수 있습니다.
- 상수 식별자의 구문은 변수 식별자와 같습니다. 문자, 밑줄이나 달러 기호 ($) 로 시작해야 하고 문자, 숫자나 밑줄을 포함할 수 있습니다.
- 상수는 스크립트가 실행 중인 동안 대입을 통해 값을 바꾸거나 재선언될 수 없습니다. 값으로 초기화해야 합니다.
- 상수에 대한 스코프 규칙은 let 블록 스코프 변수와 동일합니다. 만약 const 키워드가 생략된 경우에는, 식별자는 변수를 나타내는 것으로 간주됩니다.
- 상수는 같은 스코프에 있는 함수나 변수와 동일한 이름으로 선언할 수 없습니다. 
- 상수에 할당된 객체의 속성은 보호되지 않습니다.
# 데이터 구조 및 형
## 데이터 형
- 최신 ECMAScript 표준은 8가지 데이터 형을 정의합니다.
- 7가지 원시 데이터 형
  - Boolean. true와 false
  - null. null 값을 나타내는 특별한 키워드. (JavaScript는 대소문자를 구분하므로, null은 Null, NULL 혹은 다른 변형과도 다릅니다.)
  - undefined. 값이 정의되어 있지 않은 최상위 속성.
  - Number (en-US). 정수 또는 실수형 숫자. 예: 42 혹은 3.14159.
  - BigInt (en-US). 임의 정밀도의 정수. 예: 9007199254740992n.
  - String. 문자열. 예:"안녕"
  - Symbol. (ECMAScript 2015에 도입) 인스턴스가 고유하고 불변인 데이터 형.
- object
## 자료형 변환
- JavaScript는 동적 형지정(정형) 언어입니다.
- 변수를 선언할 때 데이터 형을 지정할 필요가 없음을 의미합니다. 
- 데이터 형이 스크립트 실행 도중 필요에 의해 자동으로 변환됨을 뜻합니다.
### 숫자와 + 연산자
- 얘는...문자랑 숫자를 구분하지 않아요.
- 뭐 이런게 다있담.
```javascript
x = 'The answer is ' + 42 // "The answer is 42"
y = 42 + ' is the answer' // "42 is the answer"
'37' - 7 // 30
'37' + 7 // "377"
```
#### 문자열을 숫자로 변환하기
- 숫자를 나타내는 값이 문자열로 메모리에 있는 경우, 변환을 위한 메서드가 있습니다.
- parseInt()
- parseFloat()
```javascript
parseInt('101', 2) // 5
'1.1' + '1.1' // '1.11.1'
(+'1.1') + (+'1.1') // 2.2
// 참고: 괄호는 명확성을 위해 추가, 필요한 것은 아닙니다.
```
## 리터럴
- 값을 나타내기 위해 리터럴을 사용
- 스크립트에 부여한 고정 값으로, 변수가 아닙니다.
### 배열 리터럴
  - 0개 이상의 식(expression) 목록
  - 각 식은 배열 요소를 나타내고 대괄호([])로 묶입니다.
  - 배열 리터럴을 사용하여 배열을 만들 때, 그 요소로 지정된 값으로 초기화되고, 그 length는 지정된 인수의 갯수로 설정
    ```javascript
    let coffees = ['French Roast', 'Colombian', 'Kona'];
    ```
  - 배열이 최상단 스크립트에서 리터럴을 사용하여 만들어진 경우, JavaScript는 배열 리터럴을 포함한 식을 평가할 때마다 배열로 해석합니다. 게다가, 함수에서 사용되는 리터럴은 함수가 호출될 때마다 생성됩니다.
  - 배열 리터럴에서 모든 요소를 지정할 필요는 없습니다. 만약 잇달아 두 개의 쉼표를 두면, 배열은 지정되지 않은 요소를 undefined로 채웁니다.
    ```javascript
    let fish = ['Lion', , 'Angel'];
    ```
    - 배열의 길이는 3

### 불리언 리터럴
-불리언 형은 true와 false의 리터럴 값을 가집니다.

### 부동 소수점 리터럴
- 부호없는 10진 정수,
- 소수점 ("."),
- 소수 (또 다른 10진수),
- 지수.
- 지수부는 "e"나 "E" 다음에 오며 부호("+"나 "-")가 달릴 수 있는 정수입니다. 부동 소수점 리터럴은 적어도 숫자 하나와 소수점 혹은 "e"(나 "E")가 있어야 합니다.

### 숫자 리터럴
- JavaScript 숫자 리터럴은 다른 진법의 정수 리터럴과 10진수의 부동 소수점 리터럴이 포함됩니다.
- 언어 명세서에 따르면 숫자 리터럴에 부호가 없어야 합니다. 그럼에도 불구하고, -123.4 와 같은 코드 괜찮습니다. 숫자 리터럴 123.4 에 단항 연산자 - 가 붙은 것으로 해석됩니다.
#### 정수 리터럴
- 정수와 BigInt 리터럴은 10진수, 16진수, 8진수 및 2진수로 표현될 수 있습니다.
- 10진수 정수 리터럴은 0으로 시작(leading zero)하지 않는 숫자열로 이루어집니다.
- 정수 리터럴에서 0으로 시작하거나 0o(혹은 0O)으로 시작하는 숫자열은 8진수임을 나타냅니다. 8진수 정수 리터럴은 오직 숫자 0-7만 포함할 수 있습니다.
- 0x(나 0X)로 시작하는 숫자열은 16진수 정수 리터럴 임을 나타냅니다. 16진수 정수는 숫자 (0-9) 및 문자 a-f, A-F를 포함할 수 있습니다. (문자의 대소문자는 그 값을 변경하지 않습니다. 그러므로 0xa = 0xA = 10 그리고 0xf = 0xF = 15 입니다.)
- 0b (나 0B)로 시작하는 숫자열은 2진수 정수 리터럴 임을 나타냅니다. 2진수 정수 리터럴은 오직 숫자 0과 1만 포함할 수 있습니다.
- n으로 끝나는 숫자열은 BigInt 리터럴 임을 나타냅니다. 정수 리터럴은 위의 어떤 진수든 사용할 수 있습니다. 0123n과 같은 0으로 시작하는 8진수 구문은 허용되지 않으나, 0o123n은 허용됩니다.
### 객체 리터럴
- 객체 리터럴은 중괄호({})로 묶인 0개 이상인 객체의 속성명과 관련 값 쌍 목록입니다.

### 정규식 리터럴
### 문자열 리터럴